Some text to debug visually the obs_swat_push_broom

if sm.cnt_epoch == 1:
    fig = plt.figure(figsize=(10, 10))
    ax = plt.axes(projection='3d')
    ax.scatter3D(sat_pos[0] / 1e3, sat_pos[1] / 1e3, sat_pos[2] / 1e3, color='blue')
    # for u in sm.users:
    #     ax.scatter3D(u.posvel_ecf[0] / 1e3, u.posvel_ecf[1] / 1e3, u.posvel_ecf[2] / 1e3, color='r')
    u, v = np.mgrid[0:2 * np.pi:20j, 0:np.pi:10j]
    x = R_EARTH / 1e3 * np.cos(u) * np.sin(v)
    y = R_EARTH / 1e3 * np.sin(u) * np.sin(v)
    z = R_EARTH / 1e3 * np.cos(v)
    ax.plot_wireframe(x, y, z, color="r")
    ax.scatter3D(self.p1[0] / 1e3, self.p1[1] / 1e3, self.p1[2] / 1e3, color='g')
    ax.scatter3D(self.p2[0] / 1e3, self.p2[1] / 1e3, self.p2[2] / 1e3, color='b')
    ax.scatter3D(self.p3[0] / 1e3, self.p3[1] / 1e3, self.p3[2] / 1e3, color='k')
    ax.scatter3D(self.p4[0] / 1e3, self.p4[1] / 1e3, self.p4[2] / 1e3, color='c')
    ax.scatter3D(planes[0].n[0] * 4e3, planes[0].n[1] * 4e3, planes[0].n[2] * 4e3, color='green')
    ax.scatter3D(planes[1].n[0] * 4e3, planes[1].n[1] * 4e3, planes[1].n[2] * 4e3, color='blue')
    ax.scatter3D(planes[2].n[0] * 4e3, planes[2].n[1] * 4e3, planes[2].n[2] * 4e3, color='black')
    ax.scatter3D(planes[3].n[0] * 4e3, planes[3].n[1] * 4e3, planes[3].n[2] * 4e3, color='cyan')
    plt.show()

# Old way for conical scanner

    def read_config(self, node):
        if node.find('OrthoViewLatitude') is not None:
            self.ortho_view_latitude = float(node.find('OrthoViewLatitude').text)

    def before_loop(self, sm):
        for satellite in sm.satellites:
            for idx, constellation in enumerate(sm.constellations):
                if satellite.constellation_id == constellation.constellation_id:
                    idx_found = idx
            const = sm.constellations[idx_found]
            sat_altitude = satellite.kepler.semi_major_axis - R_EARTH
            if const.obs_swath_stop is not None:  # if swath defined by swath length rather than incidence
                satellite.obs_incl_angle_stop = misc_fn.incl_from_swath(
                    const.obs_swath_stop, R_EARTH, sat_altitude)
            else:
                satellite.obs_incl_angle_stop = const.obs_incl_angle_stop
            alfa_critical = asin(R_EARTH / (R_EARTH + sat_altitude))  # If incidence angle shooting off Earth -> error
            if satellite.obs_incl_angle_stop > alfa_critical:
                ls.logger.error(f'Inclination angle stop: {degrees(satellite.obs_incl_angle_stop)} ' +
                                f'larger than critical angle {round(degrees(alfa_critical),1)}')
                exit()
        for user in sm.users:
            user.metric = np.zeros(sm.num_epoch)
            user.norm_ecf = norm(user.posvel_ecf[0:3])

    def in_loop(self, sm):
        # Computed by angle distance point and satellite ground point
        # Just 10% faster if done by checking normal euclidean distance
        for satellite in sm.satellites:
            norm_sat = norm(satellite.posvel_ecf[0:3])
            satellite.det_lla()
            sat_altitude = norm_sat - misc_fn.earth_radius_lat(satellite.lla[0])
            radius = misc_fn.det_swath_radius(sat_altitude, satellite.obs_incl_angle_stop)
            earth_angle_swath = radians(misc_fn.earth_angle_beta_deg(radius))
            for user in sm.users:
                angle_user_zenith = misc_fn.angle_two_vectors(user.posvel_ecf[0:3], satellite.posvel_ecf[0:3],
                                                              user.norm_ecf, norm_sat)
                if angle_user_zenith < earth_angle_swath:
                    user.metric[sm.cnt_epoch] = 1  # Within swath


                    np.diff(np.where(np.diff(user.metric)!=0))

# To find the common revisit of C and L
# But way too slow
num_users = len(lats)
num_epochs = user_metric_a.shape[1]
print(num_epochs)
print('Computing revisit between a and b')
plot_points = np.zeros((len(lats), 3))
for idx_user in range(len(lats)):
    if idx_user % 100 == 0:
        print(f'User swath coverage {idx_user} of {num_users}')
    if user_metric_a[idx_user, :].any():  # Any value bigger than 0
        swaths_idx_end = np.asarray(np.where(np.diff(user_metric_a[idx_user, :])==-1.0)).flatten()
        gaps = []
        #print(swaths_idx_end)
        for swath_idx_end in swaths_idx_end:
            #print(swath_idx_end)
            found_b = False
            cnt = 0
            while not found_b:
                if swath_idx_end+cnt < num_epochs:
                    if user_metric_b[idx_user, swath_idx_end+cnt] == 1:
                        found_b == True
                        gaps.append(cnt)
                    cnt=cnt+1
                else:
                    found_b = True
        metric = np.mean(gaps)
        plot_points[idx_user, :] = [lons[idx_user], lats[idx_user], metric]
plot_points = plot_points[~np.all(plot_points == 0, axis=1)]  # Clean up empty rows

